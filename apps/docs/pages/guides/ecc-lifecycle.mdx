import Layout from '~/layouts/DefaultGuideLayout'

export const meta = {
  id: 'ecc-lifecycle',
  title: 'ECC Development Lifecyle',
  description: 'What is the ECC Development Lifecycle',
  sidebar_label: 'Overview',
}

As you begin to learn more about ECCs and how they can benefit organisations, it's useful to look at the 
development lifecycle of an ECC from an idea all the way to its deployment.

## Determine the usecase and benefits

The first step of planning your ECC is figuring out what your organisation or application's needs are. What features do you
think would be most beneficial and suited to your requirements. Do you wish to have your own Tokenomics for the ECC or do you prefer
DJTX or any other asset as the gas or transaction fee for the network. Will it be a permissioned or open to pre-qualified validators only network.
In determining your exact requirements and whether ECCs are the best fit for them, you will have a much clearer sense of the direction you wish to take
when lauching your ECC.

### Decide what type of ECC to build & launch.

Once you've decided to use an ECC, you need to decide what type of ECC would best fit your requirements. This means
choosing the right virtual machine (VM) to create your ECC with. Currently there are three
main types of VMs to choose from:

#### EVM-Based ECC

EVM-based ECCs are forks of the Dijets Utility Chain. They support Solidity
smart contracts and all the standard [Ethereum APIs](/docs/guides/node-apis/utility-chain-api#ethereum-apis).
ECC EVMs are Dijets' implementation of an Ethereum Virtual Machine based chains.

Due to the depth and maturity of its developers community and tools, this virtual machine is by far the safest and
most widely used choice to build an ECC with. It also receives regular updates from Dijets Core team too.

#### Experimental ECC

Experimental ECCs are built with VMs on the bleeding edge of distributed ledger technology.
These are proof-of-concept VMs developed by Dijets Core Team to see how far we can take some of the ideas
for a private blockchain or an ECC. 

These VMs are mostly alpha/beta software and aren't ready for production environments yet. Although they do receive periodic updates, Dijets team hasn't audited their performance and security, internally or externally. However, these
open source projects are intended to inspire the community, and provide novel capabilities not
available inside the EVM.

If you're looking to push the boundaries of what's possible with ECCs, this is a great place to
get started.

#### Custom ECC

Custom ECCs are an open-ended interface that allow developers to build any VM they can dream.
These VMs may be a fork of an existing VM such as ECC-EVM, SpacesVM, or even a
non-Dijets-native VM such as Solana's virtual machine. Alternatively, you can build your VM
entirely from scratch using almost any programming language. See [Introduction to VMs](introduction-to-vm) 
for advice on getting started.

### Determine Tokenomics

ECCs are powered by gas tokens. When you build an ECC, you have the option to decide what token
you use and optionally, how you distribute it. You may use DJTX, an existing Utility Chain token, or a
brand new token. You'll need to decide how much of the supply you want to use to reward validators,
what kind of emitting schedule you want, and how much to airdrop. Blocks may burn transaction fees
or give them to validators as a block reward.

### Decide how to customise your ECC

After you've selected your VM, you may want to customize it. This may mean airdropping tokens to
your team in the genesis, setting how gas fees rates on your network, or changing the
behavior of your VM via precompiles. These customizations are hard to get right on paper and usually
require some trial and error to determine correctly.

## Learn Dijets-CLI

Now that you've specified your ECC requirements, the next step is learning Dijets-CLI.

Dijets-CLI is the best tool for rapidly prototyping ECCs and deploying them to production. You
can use it throughout the entire ECC development lifecycle. To get started, take a look at [Build
Your First ECC](build-ecc).

### Deploy Your ECC Locally

The first stage of ECC development involves testing your ECC on your local machine or on a
private cloud server such as Amazon EC2. The goal of this phase is to lock-in your ECC
customizations and create your full-stack dapp without the constraints of deploying on a public
network.

Development is extremely quick and updates take seconds to minutes to apply. In this phase,
you should restrict dapp access to trusted parties. Because you're interacting with a local copy of
the Dijets network, you can't access production state or other production ECCs.

### Deploy Your ECC to Dijets TestNet

The second stage of ECC development involves deploying your ECC and your dapp to the Dijets TestNet. 
This phase tests your ability to run validator nodes, coordinate all parties involved in
the ECC, and monitor network health. You can also practice using Ledgers to manage ECC
transactions.

The ECC is publicly visible and you may want to allow external users to test your
dapp. Development on Dijets TestNet is significantly slower than with local development. Updates may now take
hours to days to apply. It's important to do as much local testing as possible before moving to
Dijets TestNet.

### Deploy Your ECC to Mainnet

The final stage of ECC development is creating your ECC on Mainnet and deploying your dapp.
It's time to let your real users in.

Once your ECC is in production, you have little flexibility
to change it. Some alterations are possible, but they require days to weeks to implement and roll
out.

Your focus should shift to preserving network stability and upgrading your nodes as needed.

## Start Developing Custom VMs

If you've mastered ECC-EVM and are looking for an additional challenge, consider building a
custom VM. The Dijets network supports far more than just the EVM. Current VMs only scratch the
surface of what's possible.

Some ideas:

- Port an existing blockchain project to Dijets. For example: Use Bitcoin's VM or Solana's VM.
- Create an app-specific VM instead of a general purpose VM. For example, create a DEX
  or a CLOB VM instead of something like the EVM.
- Create a more efficient implementation of the EVM.

export const Page = ({ children }) => <Layout meta={meta} children={children} />

export default Page